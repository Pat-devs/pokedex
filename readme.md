# AI generated issues:
(review pending)

### Easy Issues

- **Hide "Something went wrong" message by default**: The error message paragraph (`<p id="error-message">`) is currently always visible on page load, showing a generic error before any action. Hide this message by default and only show it when an actual error occurs.  
    - [ ] Hide the error message element on initial load (e.g., add a CSS rule in **`css/style.css`**: `#error-message { display: none; }`, or add the `hidden` attribute to the `<p id="error-message">` in **`index.html`**).
    - [ ] Ensure that when an error does occur (e.g., a network fetch fails), the message can be shown by removing the hide style or `hidden` attribute. (The actual error-handling logic will be implemented in a later issue.)

- **Use CSS classes instead of inline styles for Pokémon cards**: In **`js/script.js`**, Pokémon list items are styled via inline styles (e.g., blue outline and image width in JavaScript). Refactor this to use CSS classes for better maintainability.  
    - [ ] Define a CSS class (e.g., `.pokemon-card`) in **`css/style.css`** for the Pokémon item wrapper. Move the current inline styles to this class (for example, add a border: `2px solid blue` or a nicer border style, and any desired width/height or padding).
    - [ ] Define a CSS class (e.g., `.pokemon-image`) in **`css/style.css`** for the Pokémon image styling. Move the inline image style (currently `width: 40%`) to this class (e.g., `.pokemon-image { width: 40%; }` or adjust as needed).
    - [ ] In **`js/script.js`**, update the code in `displayPokemonList` (and `displayPokemonDetails` if applicable) to use `element.classList.add(...)` with the new CSS class names instead of setting `element.style`.
    - [ ] Remove or avoid the now-unnecessary inline style assignments. Verify that the Pokémon cards still display with the intended styling.

- **Improve Pokémon card UI styling**: The Pokémon list is functional but looks plain (blue outline boxes). Enhance the visual design of the Pokémon cards to make the UI more appealing.  
    - [ ] In **`css/style.css`**, style the `.pokemon-card` class (or whatever class is used for the card) to be more visually appealing. For example, add some padding and margin, a background color or a subtle shadow, and maybe rounded corners (`border-radius`) instead of a simple outline.
    - [ ] Arrange the Pokémon cards in a grid or flexible layout. For example, add a rule for the `#main-container` to use CSS Grid or Flexbox so that multiple Pokémon cards can sit next to each other (and wrap to the next line for smaller screens). Ensure there is some gap between cards for better readability.
    - [ ] Add a hover effect to the Pokémon card to indicate interactivity. For instance, in CSS use `.pokemon-card:hover { background-color: #f0f8ff; cursor: pointer; }` to change the background on hover and show a pointer cursor.
    - [ ] Ensure the Pokémon name (the `<h3>` inside the card) is clearly visible (you might increase its font-size or weight in CSS) and maybe center the content of each card for a neat appearance.

- **Style the navigation bar**: The navigation bar at the top (Home, Prev, Next, Search) is unstyled HTML and could use some UI improvements for a better user experience.  
    - [ ] In **`css/style.css`**, add styling for the `<nav>` element and its children buttons/input. For example, give the nav a distinct background color and some padding to separate it from the page content.
    - [ ] Style the buttons (`#btn-home`, `#btn-prev`, `#btn-next`, `#btn-search`) with CSS: add padding, margin between them, and perhaps a nicer border or background color on the buttons. Ensure the buttons have a consistent size and font. You can also add a hover style for buttons (e.g., change background or add underline for links).
    - [ ] Style the search input field (`#search-text`) to match the buttons (set a height or vertical align so it lines up with the Search button). Add some padding inside the input and ensure the font is readable.
    - [ ] Make sure the nav layout is responsive. A simple approach is to use Flexbox: e.g., `nav { display: flex; align-items: center; gap: 0.5rem; }` so that the buttons and input line up nicely. Verify that on smaller screens the nav items wrap or scale appropriately (you might allow wrapping or use a column layout if needed).

- **Implement Home button functionality**: The "Home" button (`#btn-home`) currently does nothing. It should return the app to the main state (the initial Pokémon list).  
    - [ ] In **`js/script.js`**, add an event listener to the "Home" button. Use `document.getElementById("btn-home")` to select the button and attach a `.addEventListener("click", ...)` handler.
    - [ ] Inside the click handler, reset the view to the initial Pokémon list. You can achieve this by calling the existing logic that loads the first page of Pokémon. For example, call `displayPokemonList(getData(apiUrl))` again, using the same `apiUrl` (offset=0, limit=10) that loads the first 10 Pokémon.
    - [ ] Ensure that any currently displayed Pokémon details or search results are cleared out. The `displayPokemonList` function already clears the `#main-container`, so simply reloading the list will replace the content. Also reset any state variables used for pagination or search (e.g., set current offset back to 0, clear any search text in the input field).
    - [ ] After implementing, test that clicking "Home" always brings back the initial list (Bulbasaur, Ivysaur, etc. if those are the first ones) regardless of what was on the screen before.

### Intermediate Issues

- **Implement Search functionality**: The page has a search text box (`#search-text`) and a Search button (`#btn-search`), but they are not functional. Add the ability to search for Pokémon by name.  
    - [ ] Attach an event listener to the Search button in **`js/script.js`** (`document.getElementById("btn-search")`). When clicked, retrieve the text from the search input field (`#search-text.value`), and trim it for whitespace. If the input is empty, you might simply return or alert the user that they must enter a name.
    - [ ] Fetch the Pokémon data based on the search query. **Option 1:** Use the PokéAPI to fetch a specific Pokémon by name (e.g., GET `https://pokeapi.co/api/v2/pokemon/<name>`). If you choose this route, use `getData` with the constructed URL. On success, you will have the Pokémon's details; you can then display that single Pokémon (for example, by calling `displayPokemonDetails(data)` directly with the result, or by creating an array with one result and using `displayPokemonList`).  
      **Option 2 (advanced):** Use the PokéAPI to get a list of all Pokémon and filter it. The PokéAPI `/pokemon` endpoint can return a `count` of all Pokémon. You could call `getData("https://pokeapi.co/api/v2/pokemon")` first to get the total count, then call `getData("https://pokeapi.co/api/v2/pokemon?limit=<count>")` to retrieve the full list of Pokémon names and URLs. Filter that list in JavaScript to those whose names include the search text (tip: make it case-insensitive by comparing `name.toLowerCase()` with the search text lowercased).  
    - [ ] If one or more Pokémon match the search query, display them in the UI. You can reuse the `displayPokemonList` function by passing it a promise or data structured like the usual response (e.g., `{ results: [ ...filteredList ] }`). Another approach is to create DOM elements for the filtered results similar to how `displayPokemonList` does. Ensure that the display is cleared before showing search results (e.g., clear `#main-container.innerHTML` or reuse that logic).
    - [ ] If no Pokémon match the query (or if the API returns a 404 for a name), provide feedback to the user. For example, show a message like "No Pokémon found." You could reuse the `#error-message` paragraph for this by setting its text content to "No Pokémon found" (and making it visible), or create a new element in the main container with that message.
    - [ ] Make sure the search is usable multiple times. For instance, after showing results for one search, if the user clears the input and searches another term or clicks Home, the app should update accordingly (clear old results, etc.). Also consider clearing or hiding any error/"no results" message when a new search starts or on valid results.

- **Implement Prev/Next pagination**: The page includes "Prev" and "Next" buttons to navigate through the Pokémon list, but they are not wired up. Implement functionality to load the previous or next batch of Pokémon (in the listing of 10 per page).  
    - [ ] Decide on how to track pagination state. One simple way is to use two variables in **`js/script.js`**: e.g., `let currentOffset = 0; const limit = 10;`. The `apiUrl` can then be constructed using these (e.g., `apiUrl = "https://pokeapi.co/api/v2/pokemon?offset=" + currentOffset + "&limit=" + limit`).
    - [ ] Add event listener for the "Next" button (`#btn-next`). In the handler, increase the `currentOffset` by 10 (or whatever the `limit` is). Then fetch the next set of Pokémon using `getData` with the updated URL and display them (call `displayPokemonList` with the new promise/data). For example, if currentOffset was 0, set it to 10 and load Pokémon 11-20.
    - [ ] Add event listener for the "Prev" button (`#btn-prev`). In that handler, decrease the `currentOffset` by 10, down to a minimum of 0 (don’t go negative). Fetch that page of Pokémon and display the list. For example, if currentOffset was 20, decrement to 10 and load Pokémon 11-20. If at the start (offset 0), the Prev button should either be disabled or do nothing.
    - [ ] Update the UI state based on boundaries: If `currentOffset` is 0 (at the beginning of the list), disable or visually indicate the Prev button is not usable (you can disable the button element or just not perform any action on click). Similarly, you might determine the maximum offset (for example, using the `count` of Pokémon from the API if available) and disable/hide Next when beyond the last page. The PokéAPI `/pokemon` endpoint returns a `next` and `previous` URL in its JSON; you could use those as well instead of manually computing offsets.
    - [ ] Test the Prev/Next buttons thoroughly: clicking Next successive times should page through the Pokémon list in order, and clicking Prev should go back. Ensure that after using Prev/Next, the Home button still resets to the first page correctly.

- **Display additional Pokémon details on click**: Right now, when you click a Pokémon from the list, the detail view only shows its name and image. Enhance the detail view to show more information about the selected Pokémon (using data already retrieved from the API).  
    - [ ] In **`js/script.js`**, look at the `displayPokemonDetails(data)` function. After calling `getData(data.url)`, you have a `pokemonDetails` object which contains lots of info (e.g., types, height, weight, abilities, stats, etc.). Extract a few key pieces of information to display. For example:
        - Pokémon **Type(s)**: You can get this from `pokemonDetails.types` (an array). Each item has a `.type.name` property. You could join them to display something like "Type: Grass / Poison".
        - **Height and Weight**: `pokemonDetails.height` and `.weight` are available (note: the units are decimeters and hectograms as per the API, but you can display them as-is or convert (e.g., height 7 → 0.7 m, weight 69 → 6.9 kg) for an extra challenge).
        - **Abilities**: `pokemonDetails.abilities` is an array of ability objects; you might list the ability names.
        - Any other interesting info (like base stats or sprite images) can be added if desired.
    - [ ] Modify `displayPokemonDetails` to create new DOM elements (e.g., `<p>` or `<ul>` list items) for these additional details. For example, create a `<p>` for type and set its text to "Type: ...", then append it to the `wrapperEl`. Do the same for height/weight and other details you choose to include.
    - [ ] Style the detail view if necessary. For instance, you might want to remove the blue outline on the detail view or use a different highlight to indicate it's a detailed section. You can target the detail view via the same `.pokemon-card` class or add a new class for detail mode if needed. Ensure the added information is presented clearly (perhaps bold labels like "Height:" and the value).
    - [ ] Test by clicking a Pokémon. The detail view should now show the image, name, and the extra info you added. Make sure that the layout is still okay (you might need to adjust the styling for the detail content). Also verify that clicking Home (or using Prev/Next after implementing those) will replace the detail view with the appropriate list, as expected.

- **Optimize list rendering with a single DOM update**: The current implementation of `displayPokemonList` appends each Pokémon to the DOM one-by-one inside a loop. This can cause multiple reflows/repaints in the browser. Improve the performance by appending all items at once.  
    - [ ] In **`js/script.js`**, modify `displayPokemonList(pokemonListPromise)` so that it minimizes DOM insertions. One approach is to use a **DocumentFragment**:
        - Before the loop over `pokemonList.results`, create a fragment: `const fragment = document.createDocumentFragment()`.
        - In the loop, instead of `mainContainerEl.append(wrapperEl)` for each Pokémon, append each `wrapperEl` to the fragment (`fragment.appendChild(wrapperEl)`).
        - After the loop completes, append the fragment to `mainContainerEl` once (`mainContainerEl.append(fragment)`).
    - [ ] Make sure to still clear out `mainContainerEl` at the start of the function (e.g., `mainContainerEl.innerHTML = ""`) so that old content is removed before adding the new batch.
    - [ ] Verify that the list of Pokémon still displays correctly after your changes. The visual output should be the same, but performance is improved (especially if listing many Pokémon) because the browser will handle one bulk insertion.
    - [ ] (_Optional_) Consider removing the leftover commented-out code (`pokemonList.results.forEach(...`) if it's no longer needed, to keep the code clean.

- **Fetch Pokémon details in parallel**: Currently, for each Pokémon in the list, the code waits for one Pokémon's data to load before fetching the next (`await getData(pokemon.url)` inside a loop). This sequential fetching can be slow. Modify the code to fetch all Pokémon details concurrently to speed up loading the list.  
    - [ ] In **`js/script.js`**, update the `displayPokemonList` function to use **Promise.all** for fetching data. Instead of a `for...of` loop that `await`s each `getData(pokemon.url)`, do the following:
        - Create an array of promises for all the Pokémon details. For example: `const detailPromises = pokemonList.results.map(pokemon => getData(pokemon.url));`. This starts all fetches simultaneously.
        - Use `const detailsArray = await Promise.all(detailPromises);` to wait for all the fetch promises to resolve. This returns an array of Pokémon detail objects in the same order as the original list.
    - [ ] Once you have `detailsArray`, loop through it (e.g., using a regular `for` loop or `forEach`) to create the DOM elements for each Pokémon, similar to what the code does now inside the loop. You now have each Pokémon's details readily available (including the image URL, etc.) without additional waits.
    - [ ] Ensure that if one of the fetches fails, it is handled gracefully. You might wrap the Promise.all call in a try/catch. If an error occurs, you could still display the ones that did load or show an error message for the whole list. (For simplicity, it's okay if on a network error the whole list fails; you can handle that in the error-handling issue below by showing the error message).
    - [ ] Test that the Pokémon list still loads and displays correctly. With only 10 Pokémon (default), the speed improvement might not be very noticeable, but if you later increase the `limit` or implement a full list search, this concurrent fetching will make a big difference.

- **Add robust error handling for data fetches**: Currently, if the network request fails or returns an error, the user only sees the default "Something went wrong!" (if at all) and the console might show an unhandled exception. Improve the error handling so that the app gracefully handles fetch failures and informs the user.  
    - [ ] Modify the `getData(url)` function in **`js/script.js`** to handle exceptions. Wrap the `fetch` and `.json()` calls in a `try...catch` block.
        - In the `try` block, perform the fetch and JSON conversion as usual and return the data.
        - In the `catch` block, this means the request failed (network error or bad JSON). Here, you can do two things: (a) log the error to console for debugging (optional), and (b) return a falsy value (like `null`) or a specific error indicator that the calling code can check.
    - [ ] Utilize the `#error-message` element to display an error to the user when a fetch fails. For example, inside the catch, you might set `document.getElementById("error-message").textContent = "Failed to load data. Please check your connection and try again."` and remove the `display: none`/hidden style so that it's visible.
    - [ ] Update the parts of the code that call `getData`. Specifically, in `displayPokemonList`, after awaiting the promise, check if the result is `null` or an error value. If it is, you should not try to loop through `pokemonList.results` (as it would be undefined). Instead, you could simply return or display a message (perhaps already handled by showing the error-message in `getData`). Similarly, in `displayPokemonDetails`, after `pokemonDetails = await getData(...)`, check for an error result and if so, maybe clear the main container and show the error message instead of proceeding.
    - [ ] Ensure that the error message is hidden whenever a new successful action happens (for example, if a previous search failed and showed "No Pokémon found", and then the user clicks Home and data loads successfully, hide or reset the error message). You can achieve this by hiding the `#error-message` at the start of functions like `displayPokemonList` or whenever a successful fetch is about to display data.
    - [ ] Test error scenarios: You can simulate an error by using an incorrect URL (temporarily change `apiUrl` to something invalid) or by going offline. Confirm that a clear error message is shown in the UI instead of the app just breaking. Then restore the correct URL and ensure normal functionality returns and the error message is not shown during normal operation.